;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; Container ;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


globals [

   ContainerSequence       ;; Mutation sequence for each container, [list]
   AdjacentContainers      ;; Container Xs adjacent containers, [list]
   
   DrugSequence 
   DrugContainers
  
   ContainerVirusCounts   ;; Keeps track of the number of alive viruses in respective containers 
  
]

to initContainers 

end

to setup-env 
   while [not (withinN)] [    
      env
   ]
end

to env
    let i 0
    ;; Create an array for the container sequences
    set ContainerSequence array:from-list n-values GridCount [n-values MutationLength [-1]]
    ;; Randomly generate the first sequence
    array:set ContainerSequence 0 (n-values MutationLength [one-of [0 1]])
    
    ;; Goes through each row
    repeat 8 [ 
        setSequences i filter [ ? > i ] (getAdjacentContainers i)    
        set i i + 8
    ]
    ;; Tries to match bits 
    fixme
end

to fixme
      let i 0
      repeat GridCount [
             foreach (item i AdjacentContainers) [
                   if not (hammingDistance array:item ContainerSequence i array:item ContainerSequence ? = 2) [
                       fix i
                    ]
             ]
             set i i + 1
       ]
end

;; Checks if the entire grid is within a hamming distance of 1 or 2 of each adjacent cell
to-report withinN
   let i 0
   repeat GridCount [
          foreach (item i AdjacentContainers) [
                if (hammingDistance array:item ContainerSequence i array:item ContainerSequence ? = 0 or hammingDistance array:item ContainerSequence i array:item ContainerSequence ? > 2) [
                    report false
                 ]
          ]
          set i i + 1
    ]
    report true
end

;; Try to match the bits from container x 
to fix [ i ]
repeat GridCount [
       foreach (item i AdjacentContainers) [
           let hd hammingDistance array:item ContainerSequence i array:item ContainerSequence ? 
           if not (hd = 2) [
               ifelse (hd = 0) [ ;; Hamming distance = 0, just shuffle the bits
                    array:set ContainerSequence i shuffle (array:item ContainerSequence i)
               ][            
                   ;; Get list of matches between the two sequence
                   let diff (map [?1 = ?2] array:item ContainerSequence i array:item ContainerSequence ?)
                   let temp array:item ContainerSequence i

                   let x 0
                   ;; Get the amount of positions in sequence, shuffle them
                   foreach shuffle (n-of (MutationLength - 1) (n-values MutationLength [?])) [
                     ;; flip only two bits
                     ifelse x <= 2 [ 
                          if item ? diff = false [ ;; check if we have a disagreement, then flip the bit
                              set temp replace-item ? temp ifelse-value (item ? temp = 1) [ 0 ] [ 1 ]
                              set x x + 1
                          ]
                       ][
                           array:set ContainerSequence i temp
                       ]
                   ]
               ]
            ]
       ]
    ]
end

;; set container sequences
to setSequences [ node nodeList ]
    ;; Flip two bits of non-assigned sequences
    foreach (nodeList) [ flipBits node ? ]
    
    ;; check adjacent containers and check if they have a common container
    let common [ ]      
    foreach (getAdjacentContainers item 0 nodeList) [
        let temp ?
        if length nodeList > 1 [
           foreach (getAdjacentContainers item 1 nodeList) [
               if temp = ? [ ;; common node
                   set common ? ;; should only be one item I think
               ]
           ]
        ]
     ]
    if (is-number? common) [
        ;; set common node, based on the two adjacent nodes
        ;; with two bit switches from a common parent, shuffle the third one till it is the right hamming distance
        let temp shuffle (array:item ContainerSequence (item random 1 nodeList))
        while [ (hammingdistance temp array:item ContainerSequence (item 0 nodeList)) > 2 and (hammingdistance temp array:item ContainerSequence (item 1 nodeList)) > 2 ] [
            set temp shuffle (array:item ContainerSequence (item random 1 nodeList))
        ]
        array:set ContainerSequence common temp
        ;; do the next container
        setSequences item 0 nodeList filter [ ? > (item 0 nodeList) and ? > (item 0 nodeList)] (getAdjacentContainers item 0 nodeList)
    ]
end

;; Flips two bits in container sequence,
;; Inputs: parent index, child index
to flipBits [ main secondary ]
    if main < (GridCount - 1) and secondary < (Gridcount - 1) [
                   
    let n 2
    let temp array:item ContainerSequence main
    let pos n-of n (n-values (MutationLength - 1) [?]) ;; get two random positions in the sequence list
    let i 0
    repeat n [
        set temp replace-item (item i pos) temp ifelse-value (item (item i pos) temp = 1) [ 0 ] [ 1 ]
        set i i + 1
    ]
   array:set ContainerSequence secondary temp
   ]
end


to check
   let i 0
   let results [ ]
   repeat GridCount [
          foreach (item i AdjacentContainers) [
              if  (hammingDistance array:item ContainerSequence i array:item ContainerSequence ? > 2) [
                set results lput (list i ? hammingDistance array:item ContainerSequence i array:item ContainerSequence ?) results

              ]
          ]
          set i i + 1
    ]

    let out results
    foreach results [
        let j item 0 ?
        let k item 1 ?
        foreach results [
            set i 0
            if (j = item 1 ? and k = item 0 ?) [
                set results remove-item i results                
            ]
            set i i + 1
        ]
    ]
    
    foreach out [ print (word "Container " item 0 ? " - " item 1 ? "  ==>  " item 2 ?) ]
    print "\n\n"
    foreach results [print (word "Container " item 0 ? " - " item 1 ? "  ==>  " item 2 ?) ]
end

to draw-hd
  let i 0
  let DrawSequenceColor rgb 255 255 255
  let DrawVirusCountColor rgb 0 20 148
  clear-drawing  
  repeat GridCount  [
      let xy [ ]
      ask patches with [container = i] [ set xy (list pxcor pycor) ]

      graphics:set-text-color rgb 255 0 0
      if (sum array:item ContainerSequence i) > 0 [
          graphics:draw-text item 0 xy (item 1 xy + 0.7) "C"  reduce word (array:item ContainerSequence i) 
      ]
      graphics:set-text-color DrawSequenceColor
      ; left, right, up, down
      foreach getAdjacentContainers i [
      if (sum array:item ContainerSequence ?) >= 0 and not ((hammingdistance array:item ContainerSequence i array:item ContainerSequence ?) = 2) [
           ifelse ? > i [ ; to the right or bottom
             ifelse (i + 1) = ? [ ; right
                     graphics:draw-text (item 0 xy + 1) (item 1 xy) "C"  (word "" hammingdistance array:item ContainerSequence i array:item ContainerSequence ?) 
             ][ ; bottom
                  graphics:draw-text (item 0 xy) (item 1 xy - 1) "C"  (word "" hammingdistance array:item ContainerSequence i array:item ContainerSequence ?) 
             ]
           ][
             ifelse (i - 1) = ? [ ; left
                 graphics:draw-text (item 0 xy - 1) (item 1 xy) "C"  (word "" hammingdistance array:item ContainerSequence i array:item ContainerSequence ?) 
             ][ ; up
                 graphics:draw-text (item 0 xy) (item 1 xy + 1) "C"  (word "" hammingdistance array:item ContainerSequence i array:item ContainerSequence ?) 
             ] 
           ]
        ]
      ]
      set i i + 1
  ]
  
  ;  foreach array:to-list containersequence [ if (sum ?) > 0 [ print ? ] ]
end